/** Detray library, part of the ACTS project (R&D line)
 *
 * (c) 2023 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

#include <gtest/gtest.h>

#include <vecmem/memory/sycl/device_memory_resource.hpp>
#include <vecmem/memory/sycl/shared_memory_resource.hpp>

#include "propagator_kernel.hpp"

using namespace detray;

// Simple asynchronous handler function
auto handle_async_error = [](::sycl::exception_list elist) {
    for (auto& e : elist) {
        try {
            std::rethrow_exception(e);
        } catch (::sycl::exception& e) {
            std::cout << "ASYNC EXCEPTION!!\n";
            std::cout << e.what() << "\n";
        }
    }
};

class SyclPropagatorWithRkStepper : public ::testing::TestWithParam<vector3_t> {
};

TEST_P(SyclPropagatorWithRkStepper, propagator) {

    // Creating SYCL queue object
    ::sycl::queue q(handle_async_error);
    std::cout << "Running constant bfield propagation on device: "
              << q.get_device().get_info<::sycl::info::device::name>() << "\n";

    // VecMem memory resource(s)
    vecmem::sycl::shared_memory_resource shared_mr;

    // Set the magnetic field
    const vector3 B = GetParam();

    // Create the toy geometry
    toy_cfg.bfield_vec(B);
    auto det = create_toy_geometry<const_bfield_bknd_t, host_container_types>(
        shared_mr,
        covfie::field<const_bfield_bknd_t>(
            const_bfield_bknd_t::configuration_t{B[0], B[1], B[2]}),
        toy_cfg);

    // Create the vector of initial track parameterizations
    auto tracks_host = generate_tracks(&shared_mr);
    vecmem::vector<track_t> tracks_device(tracks_host, &shared_mr);

    // Host propagation
    auto&& [host_path_lengths, host_positions, host_jac_transports] =
        run_propagation_host(&shared_mr, det, tracks_host);

    // Device propagation
    detray::sycl::queue_wrapper queue(&q);
    auto&& [device_path_lengths, device_positions, device_jac_transports] =
        run_propagation_device<const_bfield_bknd_t>(
            &shared_mr, det, queue, tracks_device, host_positions);

    // Check the results
    compare_propagation_results(host_positions, device_positions,
                                host_path_lengths, device_path_lengths,
                                host_jac_transports, device_jac_transports);
}

INSTANTIATE_TEST_SUITE_P(SyclPropagatorValidation1, SyclPropagatorWithRkStepper,
                         ::testing::Values(vector3_t{0. * unit<scalar>::T,
                                                     0. * unit<scalar>::T,
                                                     2. * unit<scalar>::T}));

INSTANTIATE_TEST_SUITE_P(SyclPropagatorValidation2, SyclPropagatorWithRkStepper,
                         ::testing::Values(vector3_t{0. * unit<scalar>::T,
                                                     1. * unit<scalar>::T,
                                                     1. * unit<scalar>::T}));

INSTANTIATE_TEST_SUITE_P(SyclPropagatorValidation3, SyclPropagatorWithRkStepper,
                         ::testing::Values(vector3_t{1. * unit<scalar>::T,
                                                     0. * unit<scalar>::T,
                                                     1. * unit<scalar>::T}));

INSTANTIATE_TEST_SUITE_P(SyclPropagatorValidation4, SyclPropagatorWithRkStepper,
                         ::testing::Values(vector3_t{1. * unit<scalar>::T,
                                                     1. * unit<scalar>::T,
                                                     1. * unit<scalar>::T}));

/// This tests the device propagation in an inhomogenepus magnetic field

/// This tests the device propagation in an inhomogenepus magnetic field
/*TEST(SyclPropagatorValidation5, inhomogeneous_bfield) {

    // Creating SYCL queue object
    ::sycl::queue q(handle_async_error);
    std::cout << "Running constant bfield propagation on device: "
              << q.get_device().get_info<::sycl::info::device::name>() << "\n";

    // VecMem memory resource(s)
    vecmem::sycl::shared_memory_resource shared_mr;

    // Create the toy geometry with inhomogeneous bfield from file
    auto det = create_toy_geometry<inhom_bfield_bknd_t, host_container_types>(
        shared_mr, n_brl_layers, n_edc_layers);

    // Create the vector of initial track parameterizations
    auto tracks_host = generate_tracks(&shared_mr);
    vecmem::vector<track_t> tracks_device(tracks_host, &shared_mr);

    // Host propagation
    auto&& [host_path_lengths, host_positions, host_jac_transports] =
        run_propagation_host(&shared_mr, det, tracks_host);

    // Device propagation

    detray::sycl::queue_wrapper queue(&q);

    auto&& [device_path_lengths, device_positions, device_jac_transports] =
        run_propagation_device<inhom_bfield_bknd_t>(
            &shared_mr, det, queue, tracks_device, host_positions);

    // Check the results
    compare_propagation_results(host_positions, device_positions,
                                host_path_lengths, device_path_lengths,
                                host_jac_transports, device_jac_transports);
}*/
