/** Detray library, part of the ACTS project (R&D line)
 *
 * (c) 2023 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

#include "propagator_kernel.hpp"

namespace detray {

/*namespace kernels {

template <typename bfield_bknd_t>
class propagate;

}  // namespace kernels*/

/// test function for propagator
template <typename bfield_bknd_t>
void propagator_test(
    detector_host_t<bfield_bknd_t> &host_det,
    vecmem::data::vector_view<track_t> &tracks_data,
    vecmem::data::jagged_vector_view<intersection_t> &candidates_data,
    vecmem::data::jagged_vector_view<scalar> &path_lengths_data,
    vecmem::data::jagged_vector_view<vector3> &positions_data,
    vecmem::data::jagged_vector_view<free_matrix> &jac_transports_data,
    detray::sycl::queue_wrapper queue) {

    auto det_data = get_data(host_det);

    unsigned int localSize = 64;
    unsigned int globalSize = theta_steps * phi_steps;

    const auto num = (globalSize + localSize - 1) / localSize;
    const auto ndrange = ::sycl::nd_range<1>{::sycl::range<1>(num * localSize),
                                             ::sycl::range<1>(localSize)};

    reinterpret_cast<::sycl::queue *>(queue.queue())
        ->submit([&](::sycl::handler &h) {
            h.parallel_for(ndrange, [det_data, tracks_data, candidates_data,
                                     path_lengths_data, positions_data,
                                     jac_transports_data](
                                        ::sycl::nd_item<1> item) {
                detector_device_t<bfield_bknd_t> dev_det(det_data);

                vecmem::device_vector<track_t> tracks(tracks_data);
                vecmem::jagged_device_vector<intersection_t> candidates(
                    candidates_data);
                vecmem::jagged_device_vector<scalar> path_lengths(
                    path_lengths_data);
                vecmem::jagged_device_vector<vector3> positions(positions_data);
                vecmem::jagged_device_vector<free_matrix> jac_transports(
                    jac_transports_data);

                unsigned int gid = item.get_global_linear_id();

                if (gid >= tracks.size()) {
                    return;
                }

                auto stepr = rk_stepper_t<
                    typename detector_device_t<bfield_bknd_t>::bfield_type>{};
                auto nav = navigator_t<detector_device_t<bfield_bknd_t>>{};

                // Create propagator
                using propagator_device_t =
                    propagator<decltype(stepr), decltype(nav),
                               actor_chain_device_t>;
                propagator_device_t p(std::move(stepr), std::move(nav));

                // Create actor states
                inspector_device_t::state insp_state(path_lengths.at(gid),
                                                     positions.at(gid),
                                                     jac_transports.at(gid));
                pathlimit_aborter::state aborter_state{path_limit};
                parameter_transporter<transform3>::state transporter_state{};
                pointwise_material_interactor<transform3>::state
                    interactor_state{};
                parameter_resetter<transform3>::state resetter_state{};

                // Create the actor states
                auto actor_states =
                    ::detray::tie(insp_state, aborter_state, transporter_state,
                                  interactor_state, resetter_state);
                // Create the propagator state
                typename propagator_device_t::state state(
                    tracks[gid], dev_det.get_bfield(), dev_det,
                    candidates.at(gid));

                state._stepping.set_tolerance(rk_tolerance);

                state._stepping
                    .template set_constraint<step::constraint::e_accuracy>(
                        constrainted_step_size);

                p.propagate(state, actor_states);
            });
        })
        .wait_and_throw();
}

/// Explicit instantiation for a constant magnetic field
template void propagator_test<const_bfield_bknd_t>(
    detector_host_t<const_bfield_bknd_t> &,
    vecmem::data::vector_view<track_t> &,
    vecmem::data::jagged_vector_view<intersection_t> &,
    vecmem::data::jagged_vector_view<scalar> &,
    vecmem::data::jagged_vector_view<vector3_t> &,
    vecmem::data::jagged_vector_view<free_matrix> &,
    detray::sycl::queue_wrapper);

/// Explicit instantiation for an inhomogeneous magnetic field
/*template void propagator_test<inhom_bfield_bknd_t>(
    detector_host_t<inhom_bfield_bknd_t> &,
    vecmem::data::vector_view<track_t> &,
    vecmem::data::jagged_vector_view<intersection_t> &,
    vecmem::data::jagged_vector_view<scalar> &,
    vecmem::data::jagged_vector_view<vector3_t> &,
    vecmem::data::jagged_vector_view<free_matrix> &,
    detray::sycl::queue_wrapper);*/

}  // namespace detray
