import sys
import numpy as np

import sympy as sym
from sympy import Symbol, MatrixSymbol

from detray_sympy.common import (
    name_expr,
    find_by_name,
    cxx_printer,
    my_expression_print,
)


def gen_cxx_code(name_exprs, run_cse=True):
    printer = cxx_printer
    outputs = [find_by_name(name_exprs, name)[0] for name in ["full_jacobian"]]

    lines = []

    head = "template <typename full_jac_matrix_t, typename transport_jac_matrix_t, typename matrix23_t, typename matrix32_t, typename matrix81_t, typename matrix18_t> DETRAY_HOST_DEVICE void inline update_full_jacobian_impl(const transport_jac_matrix_t& transport_jacobian, const matrix32_t & b2f_dpos_dloc, const matrix32_t & b2f_ddir_dangle, const matrix32_t & b2f_dpos_dangle, const matrix81_t & path_to_free_derivative, const matrix18_t & free_to_path_derivative, const matrix23_t & f2b_dloc_dpos, const matrix23_t & f2b_dangle_ddir, full_jac_matrix_t & full_jacobian) {"
    lines.append(head)

    code = my_expression_print(
        printer,
        name_exprs,
        outputs,
        run_cse=run_cse,
    )
    lines.extend([f"  {l}" for l in code.split("\n")])

    lines.append("}")

    return "\n".join(lines)


def gen_code(output):
    transport_jacobian = (
        MatrixSymbol("transport_jacobian", 8, 8).as_explicit().as_mutable()
    )

    b2f_dpos_dloc = MatrixSymbol("b2f_dpos_dloc", 3, 2).as_explicit().as_mutable()
    b2f_ddir_dangle = MatrixSymbol("b2f_ddir_dangle", 3, 2).as_explicit().as_mutable()
    b2f_ddir_dangle[2, 0] = 0
    b2f_dpos_dangle = MatrixSymbol("b2f_dpos_dangle", 3, 2).as_explicit().as_mutable()

    path_to_free_derivative = (
        MatrixSymbol("path_to_free_derivative", 8, 1).as_explicit().as_mutable()
    )
    path_to_free_derivative[3, 0] = 0

    free_to_path_derivative = (
        MatrixSymbol("free_to_path_derivative", 1, 8).as_explicit().as_mutable()
    )
    free_to_path_derivative[0, 3] = 0
    free_to_path_derivative[0, 7] = 0

    f2b_dloc_dpos = MatrixSymbol("f2b_dloc_dpos", 2, 3).as_explicit().as_mutable()
    f2b_dangle_ddir = MatrixSymbol("f2b_dangle_ddir", 2, 3).as_explicit().as_mutable()
    f2b_dangle_ddir[0, 2] = 0

    bound_to_free_jacobian = sym.zeros(8, 6)
    bound_to_free_jacobian[0:3, 0:2] = b2f_dpos_dloc
    bound_to_free_jacobian[0:3, 2:4] = b2f_dpos_dangle
    bound_to_free_jacobian[4:7, 2:4] = b2f_ddir_dangle
    bound_to_free_jacobian[7, 4] = 1
    bound_to_free_jacobian[3, 5] = 1

    free_to_bound_jacobian = sym.zeros(6, 8)
    free_to_bound_jacobian[0:2, 0:3] = f2b_dloc_dpos
    free_to_bound_jacobian[2:4, 4:7] = f2b_dangle_ddir
    free_to_bound_jacobian[4, 7] = 1
    free_to_bound_jacobian[5, 3] = 1

    full_jacobian = (
        free_to_bound_jacobian
        * (path_to_free_derivative * free_to_path_derivative + sym.eye(8))
        * transport_jacobian
        * bound_to_free_jacobian
    )

    tmp = sym.eye(6)
    tmp[0:4, 0:5] = full_jacobian[0:4, 0:5]
    tmp[5:6, 0:5] = full_jacobian[5:6, 0:5]
    full_jacobian = tmp

    all_name_exprs = [name_expr("full_jacobian", full_jacobian)]
    code = gen_cxx_code(
        all_name_exprs,
        run_cse=True,
    )
    output.write(code + "\n")


if __name__ == "__main__":
    output = sys.stdout
    if len(sys.argv) > 1:
        output = open(sys.argv[1], "w")

    output.write(
        """/* Detray library, part of the ACTS project (R&D line)
         *
         * (c) 2025 CERN for the benefit of the ACTS project
         *
         * Mozilla Public License Version 2.0
         *
         * Note: This file is automatically generated.
         *       Do not modify it manually.
         */

        #pragma once

        #include "detray/definitions/algebra.hpp"
        #include "detray/definitions/detail/qualifiers.hpp"

        namespace detray::detail {
        """
    )

    gen_code(output)

    output.write("}")

    if output is not sys.stdout:
        output.close()
