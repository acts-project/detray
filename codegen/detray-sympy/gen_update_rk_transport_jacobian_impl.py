import sys
import numpy as np

import sympy as sym
from sympy import Symbol, MatrixSymbol

from detray_sympy.common import (
    name_expr,
    find_by_name,
    cxx_printer,
    my_expression_print,
)


def covariance_transport_generic(J_full, C):
    new_C = name_expr("new_C", J_full * C * J_full.T)

    return [new_C]


def my_covariance_transport_generic_function_print(
    name_exprs, run_cse=True, gradient=True
):
    printer = cxx_printer
    outputs = [find_by_name(name_exprs, name)[0] for name in ["new_J"]]

    lines = []

    if gradient:
        suffix = "with_gradient"
    else:
        suffix = "without_gradient"

    head = (
        "template <typename jac_matrix_t, typename matrix33_t, typename matrix31_t, typename scalar_t> DETRAY_HOST_DEVICE void inline update_transport_jacobian_"
        + suffix
        + "_impl(const jac_matrix_t& J_transport, const matrix33_t & dFdt, const matrix33_t & dGdt, "
        + ("" if not gradient else "const matrix33_t & dFdr, const matrix33_t & dGdr,")
        + " const matrix31_t & dFdqop, const matrix31_t & dGdqop, const scalar_t & dqopqop, jac_matrix_t& new_J) {"
    )
    lines.append(head)

    code = my_expression_print(
        printer,
        name_exprs,
        outputs,
        run_cse=run_cse,
    )
    lines.extend([f"  {l}" for l in code.split("\n")])

    lines.append("}")

    return "\n".join(lines)


def gen_code(output, gradient=True):
    dFdr = MatrixSymbol("dFdr", 3, 3).as_explicit().as_mutable()
    dGdr = MatrixSymbol("dGdr", 3, 3).as_explicit().as_mutable()

    dFdt = MatrixSymbol("dFdt", 3, 3).as_explicit().as_mutable()
    dGdt = MatrixSymbol("dGdt", 3, 3).as_explicit().as_mutable()

    dFdqop = MatrixSymbol("dFdqop", 3, 1).as_explicit().as_mutable()
    dGdqop = MatrixSymbol("dGdqop", 3, 1).as_explicit().as_mutable()

    dqopqop = Symbol("dqopqop")

    D = sym.eye(8)

    if gradient:
        D[0:3, 0:3] = dFdr
        D[4:7, 0:3] = dGdr

    D[0:3, 7:8] = dFdqop
    D[4:7, 7:8] = dGdqop
    D[0:3, 4:7] = dFdt
    D[4:7, 4:7] = dGdt
    D[7, 7] = dqopqop

    J_transport = MatrixSymbol("J_transport", 8, 8).as_explicit().as_mutable()

    all_name_exprs = [name_expr("new_J", D * J_transport)]
    code = my_covariance_transport_generic_function_print(
        all_name_exprs,
        run_cse=True,
        gradient=gradient,
    )
    output.write(code + "\n")


if __name__ == "__main__":
    output = sys.stdout
    if len(sys.argv) > 1:
        output = open(sys.argv[1], "w")

    output.write(
        """/* Detray library, part of the ACTS project (R&D line)
         *
         * (c) 2025 CERN for the benefit of the ACTS project
         *
         * Mozilla Public License Version 2.0
         *
         * Note: This file is automatically generated.
         *       Do not modify it manually.
         */

        #pragma once

        #include "detray/definitions/algebra.hpp"
        #include "detray/definitions/detail/qualifiers.hpp"

        namespace detray::detail {
        """
    )

    gen_code(output, False)
    gen_code(output, True)

    output.write("}")

    if output is not sys.stdout:
        output.close()
